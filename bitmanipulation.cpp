#include <iostream>
#include <vector>
using namespace std;

/*
 * Flip Bit to Win: You have an integer and you can flip exactly one bit
 * from a 0 to a 1. Write code to find the length of the longest sequence
 * of 1syou could create.
 * SOLUTION 
 * EXAMPLE   Input: 1775 (or: 11011101111) Output: 8
 *
 */
int flip(int a)
{
	// we can always has a sequence at leat 1 (we can flip one bit)
	int curLen = 0, prevLen = 0, maxLen = 1;

	if (~a == 0)
		return 32;

	while (a) {
		if ((a & 1) == 1) {
			curLen++;
		} else if ((a & 1) == 0) {
			prevLen = (a & 2) == 0 ? 0 : curLen;
			curLen = 0;
		}
		maxLen = max(maxLen, prevLen + curLen + 1);
		a >>= 1;
	}
	return maxLen;
}

/*
 * Given an integer array arr.
 * You have to sort the integers in the array in ascending order 
 * by the number of 1's in their binary representation and
 * in case of two or more integers have the same number of 1's you 
 * have to sort them in ascending orde. Return the sorted array.
 *
 */
static bool mycmp(int a, int b)
{
	int x = bitset<32>(a).count();
	int y = bitset<32>(b).count();
	if (x != y)
		return x < y;
	return a < b;
}

vector<int> sortByBits(vector<int>& arr)
{
	sort(arr.begin(), arr.end(), mycmp);
	return arr;
}


/*
 * Given 3 positives numbers a, b and c. Return the minimum flips required
 * in some bits of a and b to make ( a OR b == c ). (bitwise OR operation).
 * Flip operation consists of change any single bit 1 to 0 or
 * change the bit 0 to 1 in their binary representation.
 *
 */

int get_bits(int n, int pos)
{
	return (n & (1 << pos)) != 0;
}

int minFlips(int a, int b, int c)
{
	int flips = 0;

	for (int i = 0; i < 32; i++) {
		if (get_bit(c, i ) == 1) {
			flips += (get_bits(a, i) | get_bits(b, i)) == 0;
		}  else {
			flips += (get_bits(a, i) != 0) + (get_bits(b, i) != 0);
		}
	}
	return flips;
}

/*
 * Given two strings s and t which consist of only lowercase letters.
 * String t is generated by random shuffling string s and
 * then add one more letter at a random position.
 * Find the letter that was added in t.
 *
 */

/* or you can use sorting to resolve this problem */
char findDifference(string s, string t)
{
	char diff = 0;

	for (auto c:s)
		diff ^= c;
	for (auto c:t)
		diff ^= c;

	return diff;
}

/*
 * sum of two integer without using add
 */
int getSum(int a, int b) {
	if (b == 0)
		return a;
	int sum = a ^ b;
	int carry = (a & b & 0x7fffffff) << 1;
	return getSum(sum, carry);
}


int main()
{
	return 0;
}
